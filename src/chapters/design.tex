\section{Проектирование автоматизированного решения}

\subsection{Постановка задачи}

Исходя из определения расписания, как набора событий, где каждое событие - множество состояний, представим расписание в виде функции, определяющей состояние для каждого момента из временного промежутка (рисунок \ref{schedule-function}).

\addimgh{schedule_function}{0.6}{Функция расписания}{schedule-function}

Произведем декомпозицию процесса вычисления состояния для расписания, приведенного в качестве примера (рисунок \ref{img:schedule-function-details}).

\addimgh{schedule_function_details}{1}{Декомпозиция процесса вычисления состояния расписания}{img:schedule-function-details}

Анализируя приведенную декомпозицию можно прийти к следующим выводам:

Для всех вычислений необходим набор входных данных, назовем его областью определения.

В процессе вычисления состояния, можно выделить следующие виды действий:
\begin{easylist}
  & <<Инициирующие>> действия, разбирающие момент времени на значимые части. Данные вычисления не являются специфичными для конкретного расписания;
  & Действия по вычислению значений параметров события;
  & Действие по сведению значений параметров.
\end{easylist}

В процессе вычисления выделяется определенный порядок вычисления этапов, который не может быть нарушен.
Однако порядок вычислений внутри этапа не важен, что позволяет организовать последовательные вычисления на уровне этапов и параллельные вычисления внутри этапа.

Поскольку приложение ориентировано на представление комплексных расписаний, то список атрибутов события и действия необходимые для их вычисления будут зависеть от конкретного расписания.
Следовательно, необходим подход, при котором можно указать действия и порядок их вычисления.

Одним из вариантов реализации такого подхода является организация базы правил.
Где есть набор правил, позволяющих вычислять состояния конкретных атрибутов на всей области определения расписания.
И правило осуществляющее выборку на основе значений атрибутов.

\subsubsection{Исходные данные}

Для упрощения процесса проектирования, формализуем исходные данные.
В качестве исходных данных будем использовать расписание занятий студенческой группы 147 ФГБОУ ВО <<СГУ им. Питирима Сорокина>> на неделю c 06.05.2019 по 12.05.2019 для подгруппы <<а>> (Приложение \hyperlink{app:A}{А}).

Для представления текущего расписания была разработана транзитная структура данных в \hyperlink{json}{JSON} формате.
Структура представлена в таблице \ref{tbl:schedule-block}.

\begin{tbl}{Структура блока <<Schedule>>}{tbl:schedule-block}
  \begin{tabularx}{\textwidth}{| p{3cm} | p{3cm} | X |}
  \hline Наименование & Тип             & Описание                      \\
  \hline name         & string          & Наименование расписания       \\
  \hline period       & TDateTimePeriod & Период активности расписания  \\
  \hline fields       & string[]        & Список атрибутов событий      \\
  \hline events       & IEvent[]        & Список событий                \\
  \hline rules?       & IRule[]         & Предопределенный набор правил \\
  \hline
  \end{tabularx}
\end{tbl}

\begin{tbl}{Структура блока <<IEvent>>}{event-block}
  \begin{tabularx}{\textwidth}{| p{3cm} | p{6cm} | X |}
  \hline Наименование & Тип                                                          & Описание                                                    \\
  \hline data         & IDictionary<TValue>                                          & Значения атрибутов события                                  \\
  \hline options?     & IEventConstraints<IEventOptions>                             & Ограничения события в виде указания конкретных значений     \\
  \hline periods?     & IEventConstraints<IEventPeriods>                             & Ограничения события в виде временных периодов               \\
  \hline rules        & IEventConstraints\newline <IDictionary<TOption<TValue>{}>{}> & Ограничения события с использование предопределенных правил \\
  \hline
  \end{tabularx}
\end{tbl}

\begin{tbl}{Структура блока <<IEventConstraints<T>{}>>}{eventConstraints-block}
  \begin{tabularx}{\textwidth}{| p{3cm} | p{3cm} | X |}
  \hline Наименование & Тип & Описание            \\
  \hline includes     & T   & Включающие условия  \\
  \hline excludes     & T   & Исключающие условия \\
  \hline
  \end{tabularx}
\end{tbl}

Остальные блоки представлены в Приложении \hyperlink{app:B}{Б}.

В простейшем случае данная структура позволяет представлять любые расписания в виде списка событий.
Для расписаний представляемых преимущественно в периодическом формате возможно значительно сократить количество данных за счет использования различных типов ограничений.

Также важным свойством структуры является возможность определения пользовательских правил, использование которых может значительно упростить формирование данных.
В примере расписания из Приложения \hyperlink{app:A}{А} определено правило вычисления номера текущей пары, что позволило заменить временные ограничения пар, указанием их номера.

\subsubsection{Процесс представления}

Используя вышеприведенные знания, можно представить процесс представления расписания следующим образом:
\begin{easylist}[enumerate]
  & Конвертация транзитного формата в базу правил;
  & Выбор временного периода для представления расписания;
  & Вычисление состояний на выбранной области;
  & Выборка состояний на основе вычисленных значений.
\end{easylist}

Выделим основные сущности участвующие в процессе:
\begin{easylist}[itemize]
  & Расписание в транзитном формате;
  & Расписание в виде базы правил;
  & Временной период представления расписания;
  & Набор состояний;
  & Селектор событий;
  & Список событий.
\end{easylist}

Опишем взаимодействие сущностей приложения в терминах диаграммы классов, которая изображена на рисунке \ref{img:class-diagram}.

\addimgh{class_diagram}{1}{Взаимодействие сущностей приложения}{img:class-diagram}

\subsection{Выбор архитектуры}

Поскольку среди стейкхолдеров находятся разработчики, а сам процесс довольно комплексный и ярко выраженный лучшим способом реализации будет разделение логики и представления на отдельные компоненты.

Так для реализации логики будет разработана библиотека, содержащая методы для работы с расписаниями и покрывающая потребности разработчиков.
А для представления (отрисовки) вычисленных данных буде разработано клиентское приложение.

\subsection{Проектирование библиотеки}

Для реализации библиотеки будет использован современный язык веб-разработки - TypeScript, который является подмножеством языка JavaScript, добавляющий опциональное строгое типизирование \cite{typescript}.
Он позволяет писать большие приложения, обеспечивая надежность гибкой системой типов.
Компилируется в чистый \hyperlink{js}{JS}, позволяет исполнять код приложения на любой платформе, реализующей \hyperlink{js}{JS} окружение.

Помимо языка программирования в процессе разработки будут использованы следующие инструменты:

ESLint - утилита для линтинга исходного \hyperlink{js}{JS} кода \cite{eslint}. Позволяет:
\begin{easylist}[itemize]
  & Производить анализ качества кода;
  & Приводить код к единому стилю;
  & Избегать синтаксических ошибок;
  & Автоматически исправлять простейшие проблемы.
\end{easylist}

Jest - фреймворк для тестирования \hyperlink{js}{JS} кода с упором на простоту \cite{jest}.
Позволяет производить автоматизированное юнит-тестирование.
Приводит к значительному повышению надежности кода, что в перспективе уменьшит сложность проекта на поздних этапах.
Для тестирования \hyperlink{ts}{TS} кода используется препроцессор ts-jest.

Реализация библиотеки потребует способа генерации и передачи функций как данных.
Для решения данной проблемы необходимо разработать библиотеку, позволяющую на основе определенного алфавита, генерировать шаблоны функций.
И дающую возможность восстанавливать функцию по сгенерированному шаблону, используя набор предопределенных функций (алфавит).

\subsection{Проектирование клиентского приложения}

Для реализации нефункциональных требований пользователей возможны следующие варианты решения:

\subsubsection{Нативные приложения}

Под нативным понимается приложение, которое создается для определенной платформы и непосредственно устанавливается на устройство пользователя.
Такие приложения пользователь загружает через магазин приложений конкретной платформы.

Из положительных сторон данного решения можно выделить возможность оптимизации приложения под его целевую платформы.
Также доступны платформо-ориентированные инструменты разработки, упрощающие ее процесс.

Однако, зачастую нативные приложения более дорогие в разработке и требуют большее количество времени особенно в случае, где необходимо покрыть несколько платформ.

\subsubsection{Веб-приложения}

Данные приложения работают через веб-браузер пользователя.
Это такая категория веб-сайтов, которые сделаны так, чтобы выглядеть и использоваться как нативные приложения.

Основные преимущества веб-приложений:

\begin{easylist}
  & Функционирование на любой платформе;
  & Отсутствие необходимости в установке;
  & Бесшовное обновление (процесс, незаметный для пользователя, поскольку происходит без простоя работы системы).
\end{easylist}

Недостатки веб-приложений:

\begin{easylist}
  & Необходимость постоянного интернет подключения;
  & Ограниченная производительность;
  & Доступ к приложению через оболочку браузера.
\end{easylist}

В целом, учитывая масштаб проекта реализация клиента в виде веб-приложения наиболее актуальна.
Однако приведенные недостатки в целом не позволяют применить данный подход, в особенности невозможность работы веб-приложений без интернет подключения.

На данный момент для снятия ограничений веб-платформы может использоваться технология \hyperlink{pwa}{PWA}. Рассмотрим ее подробно.

\subsubsection{Progressive Web Application}

\hyperlink{pwa}{PWA} - это название группы приложений, которые используют стек веб-технологий и позволяют соединить простоту использования веб-приложений со специфичными для нативных приложений  возможностями \cite{progressive-web-applications}.

По своим возможностям \hyperlink{pwa}{PWA} ограничены правами доступа к ресурсам системы относительно нативных приложений.
Однако современные браузеры продолжают развиваться в данном направлении, а текущее API браузера позволяет решать широкий спектр задач.
Рассмотрим список технологий позволяющих обойти ограничения традиционных веб-приложений.

Web Workers (веб-воркеры) - это простой способ для веб-контента запускать сценарии в фоновых потоках \cite{web-workers}.
Рабочий поток может выполнять задачи без вмешательства в пользовательский интерфейс.
Выделяют следующие основные типы веб-воркеров:
\begin{easylist}
  & Выделенные воркеры - экземпляры выделенных веб-воркеров создаются главным процессом. Обмениваться данными с ними может только он;
  & Разделяемые воркеры - доступ к разделяемому воркеру может получить любой процесс, имеющий тот же источник, что и воркер;
  & Сервис воркеры -  предоставляют возможность перехватывать и обрабатывать сетевые запросы, в том числе программно управлять кэшем ответов, таким образом позволяя организовать работу приложения без подключения к сети.
\end{easylist}

WebAssembly - новый тип кода, который можно запускать в современных веб-браузерах.
Это низкоуровневый язык, похожий на ассемблер, с компактным двоичным форматом, который работает с производительностью близкой к нативной и позволяет использовать такие языки как C / C ++ \cite{web-assembly}.
Данная технология позволяет значительно увеличить производительность приложений работающих в браузере.

Web App Manifest предоставляет информацию о приложении (такую как имя, авторство, иконку и описание) в формате \hyperlink{json}{JSON-файла} \cite{web-app-manifest}.
Цель манифеста - установить веб-приложение на домашний экран устройства, предоставляя пользователю более быстрый доступ и больше возможностей.

\subsubsection{Выводы по реализации клиента}

Наиболее оптимальным вариантом реализации клиента является технология \hyperlink{pwa}{PWA}, так как она дает возможности характерные для нативных приложений, при этом сохраняя преимущества веб-приложения.

Поскольку клиент будет реализован как \hyperlink{pwa}{PWA}, то в качестве основного языка программирования логично выбрать современную спецификацию JavaScript языка - \hyperlink{es6}{ES6}.

Помимо языка программирования также необходимо выбрать фронтенд фреймворк.
Для нужд текущего проекта был выбран фреймворк - React \cite{react-js}.
Особенности данного фреймворка:

\begin{easylist}
  & Однонаправленная передача данных. Свойства передаются от родительских компонентов к дочерним;
  & Виртуальный DOM. React создает кэш структуру в памяти, что позволяет вычислять разницу между предыдущим и текущим состояниями интерфейса для оптимального обновления DOM браузера;
  & JavaScript XML (JSX) - это расширение синтаксиса JavaScript, которое позволяет использовать похожий на HTML синтаксис для описания структуры интерфейса;
  & Методы жизненного цикла позволяют разработчику запускать код на разных стадиях жизненного цикла компонента. Например:
  && shouldComponentUpdate - позволяет предотвратить перерисовку компонента с помощью возврата false, если перерисовка не необходима;
  && componentDidMount - вызывается после первой отрисовки компонента. Он часто используется для запуска получения данных с удаленного источника через API;
  && render - является важнейшим методом жизненного цикла. Каждый компонент должен иметь этот метод. Обычно этот метод вызывается при изменении данных компонента для перерисовки данных в интерфейсе.
\end{easylist}

В качестве библиотеки компонентов будет использована популярная React UI библиотека - Material-UI представляющая реакт-компоненты которые реализуют Google Material Design \cite{material-design}.

\subsection{Определение задач}

Разработку программного продукта планируется проводить на основе идеологии SCRUM.
Для ее реализации необходимо сформировать Product Backlog (таблица \ref{tbl:product-backlog}).

{
\small
\hyphenpenalty=0
\begin{longtable}{| p{0.5cm} | p{5cm} | p{2cm} | p{1.5cm} | p{4.8cm} |}
  \caption{Product Backlog} \label{tbl:product-backlog} \\
  \hline id & User Story                                                           & Importance & Initial estimate & How to demo \\
  \hline 1  & Возможность генерации и воссоздания портативных функций              & 1          & 3                & Пройти тесты для данного функционала \\
  \hline 2  & Возможность конвертации транзитного формата в базу правил            & 2          & 3                & Конвертировать исходные данные \\
  \hline 3  & Возможность генерации специфического временного промежутка           & 3          & 2                & Проитерировать полученный промежуток \\
  \hline 4  & Возможность вычисления состояний на выбранном временном промежутке   & 4          & 2                & Вычислить состояния на выбранном промежутке \\
  \hline 5  & Возможность преобразования состояний в список событий                & 5          & 2                & Преобразовать состояния в события \\
  \hline 6  & Возможность просмотра расписания                                     & 6          & 2                & Создать тестовое расписание и представить его \\
  \hline 7  & Возможность сохранения расписаний                                    & 7          & 1                & Сохранить/загрузить расписание \\
  \hline 8  & Возможность работы офлайн                                            & 8          & 2                & Запустить приложение без подключения к сети \\
  \hline 9  & Возможность выбора различных вариантов группировки                   & 9          & 2                & Использовать различные способы группировки \\
  \hline 10 & Возможность добавления пользовательских событий в готовое расписание & 10         & 2                & Добавить событие в существующее расписание \\
  \hline
\end{longtable}
}

\clearpage