\section{Проектирование}

\subsection{Определение инструментария}

Определим инструментарий для реализации системы.

\subsubsection{Клиентская часть}

Поскольку клиент будет реализован как PWA, то в качестве основного языка программирования логично выбрать современную спецификацию JavaScript языка - ES6.

Помимо языка программирования так же необходимо выбрать фронтенд фреймворка.
Основываясь на статистических данных (Приложение Б) и собственном опыте использования был выбран фреймворк - React \cite{react-js}.
Особенности данного фреймворка:

\begin{easylist}
  & Однонаправленная передача данных. Свойства передаются от родительских компонентов к дочерним.
  & Виртуальный DOM. React создает кэш структуру в памяти, что позволяет вычислять разницу между предыдущим и текущим состояниями интерфейса для оптимального обновления DOM браузера.
  & JavaScript XML (JSX) - это расширение синтаксиса JavaScript, которое позволяет использовать похожий на HTML синтаксис для описания структуры интерфейса.
  & Методы жизненного цикла позволяют разработчику запускать код на разных стадиях жизненного цикла компонента. Например:
  && shouldComponentUpdate - позволяет предотвратить перерисовку компонента с помощью возврата false, если перерисовка не необходима.
  && componentDidMount - вызывается после первой отрисовки компонента. Он часто используется для запуска получения данных с удаленного источника через API.
  && render - является важнейшим методом жизненного цикла. Каждый компонент должен иметь этот метод. Обычно этот метод вызывается при изменении данных компонента для перерисовки данных в интерфейсе.  
\end{easylist}

В качестве библиотеки компонентов будет использована популярная React UI библиотека - Material-UI представляющая реакт-компоненты которые реализуют Google Material Design \cite{material-design}.

\subsubsection{Серверная часть}

Сервер планируется реализовать на Node.js.
Помимо выбранного основного языка программирования, Node.js хорошо справляется с следующим спектром задач:

\begin{easylist}
  & JSON API. Неблокирующй ввод-вывод и JavaScript делают Node отличным вариантом для написания обертки вокруг базы данных или веб-сервиса, которая общается с клиентом в формате JSON.
  & Одностраничные приложения. Для современных веб-приложений, делающих большую часть работы в браузере, отлично подходит сервер, который может одновременно обрабатывать тысячи запросов и имеет низкое время отклика. Возможность повторного использования одного и того же кода, например валидации, на сервере и клиенте - тоже плюс.
  & Потоковая обработка данных. Традиционные стеки веб-приложений обычно трактуют запросы и ответы HTTP, как атомарные события. Но на самом деле это потоки, и приложения Node.js могут воспользоваться этим фактом. Отличные примеры - обработка файлов во время загрузки на сервер или передача данных между разными слоями.  
\end{easylist}

Представленные преимущества Node.js позволят реализовать PWA наиболее простым и эффективным способом используя один тот же язык на стороне клиента и сервера.

\subsection{Выявление сущностей приложения}

Из постановки задачи выделим сущности и их методы, участвующие в процессе представления расписания.

\begin{easylist}
  & Правило - выражение и набор аргументов, которое оно может принимать. Значение вычисления - состояние из множества которое описывает данное правило
  & Расписание - набор правил и временной промежуток на котором оно определено
  & Событие - представлено парой состояния события и набором временных меток
  & Вычислитель - механизм, который загружает набор правил, выстраивая их иерархию и производит вычисления состояний для каждого момента времени действия расписания, обходя дерево правил. Во время вычисления, происходит запоминание состояний событий с привязкой к моменту времени для правил, производящих слияние параметров. Результат вычисления - набор событий.
  & Группа - событие с временной меткой начала и параметром длительность, то есть временной отрезок
  & Группировщик - механизм, строящий временную шкалу с  расположенными на ней временными метками. Эти действия выполняются на основе набора событий. Затем группировщик объединяет их в временные отрезки, набор которых представляет расписание.  
\end{easylist}

Опишем взаимодействие сущностей приложения в терминах диаграммы классов, которая изображена на рисунке \ref{class-diagram}.

\addimg{class_diagram}{0.7}{Взаимодействие сущностей приложения}{class-diagram}

\subsection{Определение задач}

Разработку программного продукта планируется проводить на основе идеологии SCRUM.
Для ее реализации необходимо сформировать Product Backlog (таблица \ref{product-backlog}).

\begin{tbl}{Product Backlog}{product-backlog}
  \begin{tabularx}{\textwidth}{| p{0.5cm} | p{4.5cm} | p{2cm} | p{1.5cm} | X |}
  \hline id
  & User Story
  & Importance
  & Initial estimate
  & How to demo \\
  \hline 1
  & Возможность просмотра расписания
  & 1
  & 2
  & Создать тестовое расписание и представить его \\
  \hline 2 
  & Возможность сохранения расписаний
  & 2
  & 1
  & Сохранить/загрузить расписание \\
  \hline 3
  & Возможность  работы офлайн
  & 3
  & 2
  & Запустить приложение без подключения к сети \\
  \hline 4
  & Возможность создания расписания с извлечением данных
  & 4
  & 3
  & Создать расписание на основе реально существующего расписания \\
  \hline 5
  & Возможность выбора различных вариантов группировки
  & 5
  & 2
  & Использовать различные способы группировки \\
  \hline 6
  & Возможность генерации непериодических расписаний
  & 6
  & 4
  & Сгенерировать расписание \\
  \hline 7
  & Возможность добавления пользовательских событий в готовое расписание
  & 7
  & 2
  & Добавить событие в существующее расписание \\
  \hline
  \end{tabularx}
\end{tbl}