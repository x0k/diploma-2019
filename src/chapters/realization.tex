\section{Реализация}

На данном этапе работы над проектом была выбрана user story под номером 1 - возможность просмотра расписания.
Для ее реализации необходимо решить ряд задач:

\begin{easylist}
  & Реализовать способ описания правил
  & Создать тестовое расписание
  & Реализовать класс “Calculator”
  & Реализовать класс “Grouper”
\end{easylist}

\subsection{Реализация описания правил}

Для записи выражения правила определим синтаксис с следующими операциями:

\begin{easylist}
  & Математические операции
  && +, -, *, /, =
  && Even - проверка на четность
  && Odd - проверка на нечетность
  & Логические операции
  && And - логическое И, возвращает последний аргумент
  && Or - логическое ИЛИ, возвращает первый “положительный элемент” (элемент, значение которого приводится к значению “истина”)
  && Not - логическое отрицание
  & Операции со списками
  && Every - проверка каждого элемента списка на положительность, возвращает список
  && Any - проверка элементов списка на положительность, возвращает первый положительный элемент
  & Операции по работе с датой
  && Операции сравнения
  && Today - проверка на соответствие даты дате в момент вычисления
  && Before - строгая проверка того, дата в момент вычисления меньше указанной
  && After - нестрогая проверка того, дата в момент вычисления больше указанной
  && In - проверка даты в момент вычисления на вхождение в заданный временной период
  & Операции создания
  && Time - создание даты на основе текущей с указанным часом и минутой
  && Date - создание даты на основе текущей с указанным  месяцем и числом
  && FullDate - создание даты на основе текущей с указанным  годом, месяцем и числом
  & Операции по взаимодействию с состояниями
  && Get - получение состояния по указанному id
  && GetDate - извлечение части даты на момент вычисления
  & Операции преобразования
  && Map - создание ассоциативного массива, где ключ - указанный id, а значение - состояние
  && toDate - преобразование формата UNIX Epoch time к объекту дата
  && toBool - преобразование элемента к булевому типу
\end{easylist}

Запись выражения производится в префиксном виде, для упрощения процесса преобразования.
В случае операций с фиксированной арностью скобки можно опускать, операции и операнды перечисляются через запятую.
Пример выражения представлен в листинге \ref{expression-example}.

\begin{lstlisting}[caption={Пример выражения в строковом представлении},label={expression-example}]
  ["and","in","date",0,14,"date",0,16,"Проектирование информационных систем"]
\end{lstlisting}

\subsection{Составление тестового расписания}

В качестве исходного расписания возьмем расписание экзаменов группы 147 представленное в таблице \ref{exam-schedule}.

\begin{tbl}{Расписание экзаменов 147 группы}{exam-schedule}
  \begin{tabularx}{\textwidth}{| X | p{3cm} | p{3cm} | p{3cm} |}
    \hline Дисциплина
    & Преподаватель
    & Дата и время консультации
    & Дата и время экзамена \\
    \hline Реинжиниринг и оптимизация бизнес-процессов
    & Бабенко В.В.
    & 10.01 в 10:00
    & 11.01 в 9:00 \\
    \hline Основы инженерии знаний
    & Миронов В.В.
    & 18.01 в 15:00
    & 19.01 в 9:00 \\
    \hline Проектирование информационных систем
    & Бабенко В.В.
    & 14.01 в 10:00
    & 15.01 в 9:00 \\
    \hline
  \end{tabularx}
\end{tbl}

Определим правила для вычисления преподавателя (листинг \ref{teacher-rules})

\begin{lstlisting}[caption={Правила для вычисления преподавателя},label={teacher-rules}]
  {
     id: 'Babenko',
     require: ['minute'],
     expression: [ 'and', 'or', [
       'and', [
         'in', 'time', 9, 0, 'time', 10, 30,
         'or', [
           'today', 'date', 0, 11,
           'today', 'date', 0, 15,
         ] ],
       'and', [
         'in', 'time', 10, 0, 'time', 11, 0,
         'or', [
           'today', 'date', 0, 10,
           'today', 'date', 0, 14,
         ] ],
     ], 'Бабенко В. В.' ],
   },
   {
     id: 'Mironov',
     require: ['minute'],
     expression: [ 'and', 'or', [
       'and', [
         'today', 'date', 0, 19,
         'in', 'time', 9, 0, 'time', 10, 30,
       ],
       'and', [
         'today', 'date', 0, 18,
         'in', 'time', 15, 0, 'time', 16, 0,
       ] ],
     'Миронов В. В.' ]
   },
   {
     id: 'teacher',
     require: [ 'Babenko', 'Mironov' ],
     expression: [ 'any', [  'get', 'Babenko', 'get', 'Mironov' ] ]
   }
\end{lstlisting}

Далее необходимо определить правила для выведения типа события (листинг \ref{type-rules}).

\begin{lstlisting}[caption={Правила для вычисления типа события},label={type-rules}]
  {
     id: 'exam',
     require: ['date'],
     expression: [ 'and', 'any', [
       'today', 'date', 0, 11,
       'today', 'date', 0, 15,
       'today', 'date', 0, 19,
     ], 'Экзамен' ],
   },
   {
     id: 'consultation',
     require: ['date'],
     expression: [ 'and', 'any', [
       'today', 'date', 0, 10,
       'today', 'date', 0, 14,
       'today', 'date', 0, 18,
     ], 'Консультация' ],
   },
   {
     id: 'type',
     require: ['exam', 'consultation'],
     expression: [ 'any', [ 'get', 'exam', 'get', 'consultation' ] ]
   },
\end{lstlisting}

Наконец, правила вычисления предмета (листинг \ref{subject-rules}).

\begin{lstlisting}[caption={Правила для вычисления предмета},label={subject-rules}]
  {
    id: 'Reengineering',
    require: ['date'],
    expression: [ 'and', 'in', 'date', 0, 10, 'date', 0, 12, 'Реинжиниринг и оптимизация бизнес процессов' ],
  },
  {
    id: 'KnowledgeEngineering',
    require: ['date'],
    expression: [ 'and', 'in', 'date', 0, 18, 'date', 0, 20, 'Основы инженерии знаний' ],
  },
  {
    id: 'SystemDesign',
    require: ['date'],
    expression: [ 'and', 'in', 'date', 0, 14, 'date', 0, 16, 'Проектирование информационных систем' ],
  },
  {
    id: 'subject',
    require: [ 'Reengineering', 'KnowledgeEngineering', 'SystemDesign' ],
    expression: [ 'any', [ 'get', 'Reengineering', 'get', 'KnowledgeEngineering', 'get', 'SystemDesign' ] ]
  },
\end{lstlisting}

Используя данные правила можно определить правило для получения выходных данных (листинг \ref{event-selector}).

\begin{lstlisting}[caption={Правило слияния параметров события},label={event-selector}]
  extractor: {
   require: [ 'type', 'teacher', 'subjects' ],
   expression: [ 'and', 'every', [ 'get', 'type', 'get', 'teacher', 'get', 'subject' ], '+', 'get', 'type', '+', ', ', '+', 'get', 'subject', '+', ', ', 'get', 'teacher' ],
 }
\end{lstlisting}

\subsection{Реализация класса “Calculator”}

Логику работы данного класса можно разделить на два уровня: загрузчик и итератор.

\subsubsection{Загрузчик}

На данном уровне инкапсулируется логика работы по загрузке данных из расписания, а именно преобразование правил из строкового значения в нативную функцию и подключении правила для отслеживания состояния событий.

Для каждого правила происходит преобразование его выражения в нативную функцию посредством вызова метода toHandler.
Приведем код его реализации в листинге \ref{converter-method}.

\begin{lstlisting}[caption={Метод конвертации выражения в нативную функцию},label={converter-method}]
  static toHandler (flow) {
  let get = (array, index) => {
      let el = array[index];
      if (el in operations)
        return operations[el];
      return el;
    },
    isArr = (value) => Array.isArray(value),
    perform = (flow) => {
      let parameters = [];
      for (let i = flow.length - 1; i >= 0; i--) {
        let element = get(flow, i);
        if (isArr(element)) {
          parameters.unshift(perform(element));
        } else if (typeof(element) === 'function') {
          if (isArr(parameters[0])) {
            parameters.unshift(element(...parameters.shift()));
          } else {
            let len = element.length;
            parameters.unshift(len ? element(...parameters.splice(0, len)) : element());
          }
        } else {
          parameters.unshift(() => element);
        }
      }
      return parameters;
    },
    expression = perform(flow)[0];
  return (data) => expression(data);
  }
\end{lstlisting}

\subsubsection{Итератор}

Выстраивание иерархии правил происходит в момент их добавления.
Добавление правила в иерархию происходит следующим образом:
\begin{easylist}[enumerate]
  & Поиск путей в иерархии правил для правил из области определения правила
  & Выбор пути, по которому правило будет добавлено
  && Сортировка путей полученных в предыдущем пункте. Происходит таким образом, чтобы в приоритете оказались наиболее часто обновляемые правила.
  && Выбор путей с наиболее часто обновляемым инициирующим правилом. Если осталось больше одного пути, то перейти к следующему шагу, иначе - вернуть найденный путь
  && Выделение наибольшей общей части среди оставшихся путей
\end{easylist}

Данный способ построения иерархии правил обеспечивает вызов правил не раньше правил, указанных в области определения, а также наименьшее количество бесполезных возбуждений правил.
Пример иерархии правил:

\begin{easylist}
  & Year
  && Month
  &&& Date
  &&&& Exam
  &&&& Consultation
  &&&& Type
  &&&& Reengineering
  &&&& KnowledgeEngineering
  &&&& SystemDesign
  &&&& Subject
  &&& Week
  &&&& Day
  &&&&& Hour
  &&&&&& Minute
  &&&&&&& Babenko
  &&&&&&& Mironov
  &&&&&&& Teacher
  &&&&&&& Extractor
\end{easylist}

В момент вызова метода “run” начинается итерация по указанному временному промежутку и для каждого момента происходит вычисление состояния событий.

\subsection{Реализация класса “Grouper”}

Первым этапом группировки является формирование временных отрезков.
Процесс вычисления временных отрезков заключается в расположении событий на временной прямой и последующем объединении событий в отрезки в том случае, если события идентичны.

Вторым этапом является группировка временных отрезков по заданному временному промежутку, например, дню или неделе.

\subsection{Применение}

Решив поставленные задачи, можно переходить к организации взаимодействия компонентов.
Поскольку операции по загрузке, вычислению и группировке могут занимать значительное время, данные методы были реализованы как асинхронные. В таком случае работа с разработанными классами может быть реализована так, как показано в листинге \ref{example-script}.

\begin{lstlisting}[caption={Пример работы с разработанными компонентами},label={example-script}]
  const beginDate = new Date(2019, 0, 10),
  endDate = new Date(2019, 0, 20),
  calc = new Calculator();
 
 calc.load(data)
  .then(rule => calc.run(beginDate, endDate))
  .then(events => Grouper.toList(events))
  .then(data => Grouper.groupBy('day', data))
  .then(grouped => console.log(grouped));
\end{lstlisting}

Для понимания процесса представления расписания, использующего вышеприведенные данные опишем его в терминах диаграммы активностей (рисунок \ref{activity-diagram}).

\addimg{activity_diagram}{0.8}{Процесс представления расписания}{activity-diagram}

Результат работы алгоритма для тестового расписания представлен на рисунке \ref{example-app}.

\addimg{example_app}{0.8}{Расписание экзаменов}{example-app}