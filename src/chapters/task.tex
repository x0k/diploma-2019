\section{Постановка задачи}

\subsection{Определение подхода к реализации функциональных требований}

Исходя из определения расписания, как набора событий, где каждое событие - множество состояний, представим расписание в виде функции, определяющей состояние для каждого момента из временного промежутка.

\addimg{schedule_function}{0.8}{Функция расписания}{schedule-function}

Произведем декомпозицию процесса вычисления состояния для расписания, приведенного в качестве примера (рисунок \ref{schedule-function-details}).

\addimg{schedule_function_details}{0.8}{Декомпозиция процесса вычисления состояния расписания}{schedule-function-details}

Анализируя приведенную декомпозицию можно прийти к следующим выводам:

\begin{easylist}
  & Для всех вычислений необходим набор входных данных, назовем его областью определения
  & В процессе вычисления состояния, можно выделить следующие виды действий:
  && “Инициирующие” действия, разбирающие момент времени на значимые части. Данные вычисления не являются специфичными для конкретного расписания
  && Действия по вычислению значений параметров события
  && Действие по сведению значений параметров
  & Особенности при выполнении вычислений на некотором временном промежутке:
  && Выделим 4 этапа вычислений. Если состояния на конкретном этапе не отличаются от предыдущих состояний, то вычислении состояний следующего этапа не имеет смысла. То есть если при изменении момента времени на 1 минуту состояние звонка не изменилось, то нет необходимости в дальнейших вычислениях, так как они приведут к таким же результатам
  && Выделим организованную по инициирующим событиям иерархию. В случае, если при изменении момента времени не произошло изменение номера недели, который составляет область определения действия по вычислению режима недели, то вычислять режим не имеет смысла
\end{easylist}

Поскольку приложение ориентировано на представление комплексных расписаний, то список параметров события и действия необходимые для их вычисления будут зависеть от конкретного расписания.
Следовательно, необходим подход, при котором можно указать действия и порядок их вычисления.

Одним из вариантов реализации такого подхода является организация базы правил, где каждое правило определяет некоторый набор состояний на своей области определения, исходя из которой возможно построить иерархию вычислений этих правил.

В таком случае, для создания расписания необходимо зафиксировать события, их списки параметров и принимаемые ими состояния, определенные на временном промежутке расписания.
Затем сформировать правила, вычисляющие состояния параметров событий и добавить действие для сведения результатов.

В свою очередь для представления расписания необходимо для каждого момента временного промежутка, на котором оно определено, вычислить состояния его событий и выполнить их группировку.

\subsection{Архитектура решения}

Для удовлетворения требования “автообновление расписаний”, в системе необходимо предусмотреть узел, отвечающий за хранение актуальной версии расписания и позволяющий, его получить.
В свою очередь узел представляющий расписание, должен проверять наличие обновлений на узле хранения.

Таким образом для разрабатываемой системы наиболее рациональным решением является клиент-серверная архитектура, где сервер - хранит актуальные версии расписаний, а клиент - в свою очередь выполняет обработку и имеет возможность актуализации хранимых расписаний.

\subsection{Способ реализации сервера}

Для соответствия текущей архитектуре, на стороне сервера необходимо реализовать интерфейс авторизации и управления данными, позволяющий загружать, актуализировать и удалять хранимые расписания.

Для организации хранения данных на стороне сервера, необходима база данных реализующая схему данных изображенную на рисунке \ref{schedules-erd}.

\addimg{schedules_erd}{0.8}{ER-диаграмма БД сервера}{schedules-erd}

Описание использованных сущностей:

\begin{easylist}
  & Schedule
  && Name - наименование расписания
  && Extractor - хранит id события, описывающего расписание
  && Date\_from - дата начала действия расписания
  && Date\_to - дата окончания действия расписания
  & Event
  && Require - область определения события
  && Expression - строка содержащая выражение, результат вычисления выражения - некоторое состояние (например, событие “day” может принимать значения от 0 до 6, определяя текущий день недели).
\end{easylist}

\subsection{Способы реализации клиента}

Для реализации нефункциональных требований возможны следующие варианты решения:￼

\subsubsection{Нативные приложения}

Под нативным понимается приложение, которое создается для определенной платформы и непосредственно устанавливается на устройство пользователя.
Такие приложения пользователь загружает через магазин приложений конкретной платформы

Из положительных сторон данного решения можно выделить возможность оптимизации приложения под его целевую платформы.
Также доступны платформо-ориентированные инструменты разработки, упрощающие ее процесс.

Однако, зачастую нативные приложения более дорогие в разработке и требуют большее количество времени особенно в случае, где необходимо покрыть несколько платформ.

\subsubsection{Веб-приложения}

Данные приложения работают через веб-браузер пользователя.
Это такая категория веб-сайтов, которые сделаны так, чтобы выглядеть и использоваться как нативные приложения.

Основные преимущества веб-приложений:

\begin{easylist}
  & Функционирование на любой платформе
  & Отсутствие необходимости в установке
  & Бесшовное обновление (процесс, незаметный для пользователя, поскольку происходит без простоя работы системы)
\end{easylist}

\begin{easylist}
  & Необходимость постоянного интернет подключения
  & Ограниченная производительность
  & Доступ к приложению через оболочку браузера
\end{easylist}

В целом, учитывая масштаб проекта реализация клиента в виде веб-приложения наиболее актуальна.
Однако приведенные недостатки в целом не позволяют применить данный подход, в особенности невозможность работы веб-приложений без интернет подключения.

На данный момент для снятия ограничений существует технология PWA. Рассмотрим ее подробно.


\subsubsection{Progressive Web Application}

PWA - это название группы приложений, которые используют стек веб-технологий и позволяют соединить простоту использования веб-приложений со специфичными для нативных приложений  возможностями \cite{progressive-web-applications}.

По своим возможностям PWA ограничены правами доступа к ресурсам системы относительно нативных приложений.
Однако современные браузеры продолжают развиваться в данном направлении, а текущий список API (Приложение А) позволяет решать широкий спектр задач.
Рассмотрим список технологий позволяющих обойти ограничения традиционных веб-приложений.

Service Worker представляет собой скрипт, который браузер запускает в фоновом режиме, отдельно от веб-страницы, открывая доступ к функциям, которые не нуждаются в веб-странице или взаимодействии с пользователем \cite{service-worker}.
Основная функция - это возможность перехватывать и обрабатывать сетевые запросы, в том числе программно управлять кэшем ответов, таким образом позволяя организовать работу приложения без подключения к сети.

WebAssembly - новый тип кода, который можно запускать в современных веб-браузерах. Это низкоуровневый язык, похожий на ассемблер, с компактным двоичным форматом, который работает с производительностью близкой к нативной и позволяет использовать такие языки как C / C ++ \cite{web-assembly}.
Данная технология позволяет значительно увеличить производительность приложений работающих в браузере.

Web App Manifest предоставляет информацию о приложении (такую как имя, авторство, иконку и описание) в формате JSON-файла \cite{web-app-manifest}.
Цель манифеста - установить веб-приложение на домашний экран устройства, предоставляя пользователю более быстрый доступ и больше возможностей.

\subsubsection{Итог}

Наиболее оптимальным вариантом реализации клиента является технология PWA, так как она дает возможности характерные для нативных приложений, при этом сохраняя преимущества веб-приложения.
